Package compiladorCMenos;

Helpers

	char = [0 .. 0xffff];
	digito = ['0' .. '9'];
	letra = [['a' .. 'z'] + ['A' .. 'Z']];
	linha = 10 | 13 | 10 13;

States
	normal, coment;

Tokens

	{normal} branco = ([' ' + 9] | linha)+;
	{normal} p_chave_else = 'else';
	{normal} p_chave_if = 'if';
	{normal} p_chave_int = 'int';
	{normal} p_chave_string = 'string';
	{normal} p_chave_return = 'return';
	{normal} p_chave_void = 'void';
	{normal} p_chave_while = 'while';
	{normal} id = letra+;
	{normal} num = digito+;
	{normal} str = '"' ([char - ['"' + '\'] ]* '\' char) * [char - ['"' + '\'] ]* '"';
	{normal} soma = '+';
	{normal} sub = '-';
	{normal} mult = '*';
	{normal} div = '/';
	{normal} menor = '<';
	{normal} maior = '>';
	{normal} menor_i = '<=';
	{normal} maior_i = '>=';
	{normal} igual = '==';
	{normal} dif = '!=';
	{normal} atrib = '=';
	{normal} p_virg = ';';
	{normal} virg = ',';
	{normal} a_par = '(';
	{normal} f_par = ')';
	{normal} a_col = '[';
	{normal} f_col = ']';
	{normal} a_chave = '{';
	{normal} f_chave = '}';
	{normal} coment_linha = '//' [char - [10 + 13]]*;
	{normal->coment, coment} coment_anin = '/*' ([char - '*']* '*'+ [char - ['*' + '/']])* [char - '*']*;
	{coment} f_coment_anin = '*'+ '/';

Ignored Tokens
	branco, coment_linha, coment_anin;

Productions
	programa = [decls]:seq_declaracao? [func_main]:decl_funcao_main;

	seq_declaracao = declaracao+;

	decl_funcao_main = [void]:tipo_avalorado [main]:id a_par p_chave_void f_par [bloco]:bloco;

	declaracao =
		  {variavel} decl_variavel p_virg
		| {funcao}   decl_funcao;

	decl_variavel =
		  {variavel} [tipo]:tipo_valorado [nome]:id
		| {matriz}   [tipo]:tipo_valorado [nome]:id a_col [dimens]:seq_parametro f_col;

	decl_funcao =
		  {normal}        [tipo]:tipo [nome]:id a_par [params]:seq_decl_parametro? f_par [bloco]:bloco
		| {sem_parametro} [tipo]:tipo [nome]:id a_par tipo_avalorado f_par [bloco]:bloco;

	tipo =
		  {valorado}  tipo_valorado
		| {avalorado} tipo_avalorado;

	tipo_valorado =
		  {int}    p_chave_int
		| {string} p_chave_string;
	
	tipo_avalorado = p_chave_void;

	seq_decl_parametro =
		  {lista} [params]:seq_decl_parametro virg [param]:decl_parametro
		| {unico} [param]:decl_parametro;

	decl_parametro =
		  {variavel} [tipo]:tipo_valorado [nome]:id
		| {matriz}   [tipo]:tipo_valorado [dimens]:mult+ [nome]:id;

	bloco = a_chave [comandos]:seq_comando? f_chave;

	seq_comando = comando+;

	comando =
		  {sem_sub_comando} sem_sub_comando
		| {repeticao}       comando_repeticao
		| {condicao}        comando_condicao
		| {condicao_else}   comando_condicao_else;

	comando_if_nao_curto =
		  {sem_sub_comando}            sem_sub_comando
		| {repeticao_if_nao_curto}     comando_repeticao_if_nao_curto
		| {condicao_else_if_nao_curto} comando_condicao_else_if_nao_curto;

	sem_sub_comando = 
	      {bloco}      bloco
	    | {declaracao} [decl]:decl_variavel p_virg
	    | {atribuicao} [atrib]:comando_atribuicao p_virg
	    | {funcao}     [func]:comando_funcao p_virg
	    | {retorno}    [retrn]:comando_retorno p_virg;

	comando_atribuicao =
		  {variavel} [nome]:id atrib [valor]:exp_geral
		| {matriz}   [nome]:id a_col [indices]:seq_parametro f_col atrib [valor]:exp_geral;

	comando_repeticao = p_chave_while a_par [condicao]:exp_geral f_par [comandos]:comando;

	comando_condicao = p_chave_if a_par [condicao]:exp_geral f_par [then_comandos]:comando;

	comando_condicao_else = p_chave_if a_par [condicao]:exp_geral f_par [then_comandos]:comando_if_nao_curto p_chave_else [else_comandos]:comando;

	comando_repeticao_if_nao_curto = p_chave_while a_par [condicao]:exp_geral f_par [comandos]:comando_if_nao_curto;

	comando_condicao_else_if_nao_curto = p_chave_if a_par [condicao]:exp_geral f_par [then_comandos]:comando_if_nao_curto p_chave_else [else_comandos]:comando_if_nao_curto;

	comando_funcao = [nome]:id a_par [args]:seq_parametro? f_par;

	seq_parametro =
		  {lista} [args]:seq_parametro virg [arg]:exp_geral
		| {unico} [arg]:exp_geral;

	comando_retorno = p_chave_return [valor]:exp_geral;

	exp_geral =
		  {op_bool} [esq]:exp op_bool [dir]:exp
		| {exp}     exp;

	exp =
		  {op_soma} [esq]:exp op_soma [dir]:termo
		| {termo}   termo;

	termo =
		  {op_mult} [esq]:termo op_mult [dir]:fator
		| {fator}   fator;

	fator =
		  {id}     id
		| {num}    num
		| {str}    str
		| {funcao} comando_funcao
		| {par}    a_par [exp]:exp_geral f_par;

	op_bool =
		  {maior_que}      maior
		| {maior_ou_igual} maior_i
		| {menor_que}      menor
		| {menor_ou_igual} menor_i
		| {igual}          igual
		| {diferente}      dif;

	op_soma =
		  {soma} soma
		| {sub}  sub;

	op_mult =
		  {mult} mult
		| {div}  div;